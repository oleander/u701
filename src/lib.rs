#![allow(dead_code)]
#![feature(assert_matches)]

extern crate lazy_static;
use lazy_static::lazy_static;

extern crate hashbrown;
use hashbrown::HashMap;

extern crate log;
use log::info;

extern crate spin;
use spin::Mutex;

#[derive(PartialEq, Debug, Copy, Clone)]
pub struct MediaKeyReport(u8, u8);
pub type ID = u8;

// The BLE event generated by the button
#[derive(Debug, PartialEq, Clone)]
pub enum BLEEvent {
  MediaKey(MediaKeyReport),
  Letter(u8),
}

// The click event generated by the button
// Press event: [0, 0, ID, 0]
// Release event: [0, 0, 0, 0]
type ClickEvent = [u8; 4];

// If the button was released or pressed
#[derive(Copy, Clone, Debug, PartialEq)]
pub enum PushState {
  Down(ID),
  Up(ID),
}

const KEY_MEDIA_NEXT_TRACK: MediaKeyReport = MediaKeyReport(1, 0);
const KEY_MEDIA_PREV_TRACK: MediaKeyReport = MediaKeyReport(2, 0);
const KEY_MEDIA_STOP: MediaKeyReport = MediaKeyReport(4, 0);
const KEY_MEDIA_PLAY_PAUSE: MediaKeyReport = MediaKeyReport(8, 0);
const KEY_MEDIA_EJECT: MediaKeyReport = MediaKeyReport(16, 0);
const KEY_MEDIA_VOLUME_UP: MediaKeyReport = MediaKeyReport(32, 0);
const KEY_MEDIA_VOLUME_DOWN: MediaKeyReport = MediaKeyReport(64, 0);
const KEY_MEDIA_WWW_HOME: MediaKeyReport = MediaKeyReport(128, 0);
const KEY_MEDIA_LOCAL_MACHINE_BROWSER: MediaKeyReport = MediaKeyReport(0, 1);
const KEY_MEDIA_CALCULATOR: MediaKeyReport = MediaKeyReport(0, 2);
const KEY_MEDIA_WWW_BOOKMARKS: MediaKeyReport = MediaKeyReport(0, 4);
const KEY_MEDIA_WWW_SEARCH: MediaKeyReport = MediaKeyReport(0, 8);
const KEY_MEDIA_WWW_STOP: MediaKeyReport = MediaKeyReport(0, 16);
const KEY_MEDIA_WWW_BACK: MediaKeyReport = MediaKeyReport(0, 32);
const KEY_MEDIA_CONSUMER_CONTROL_CONFIGURATION: MediaKeyReport = MediaKeyReport(0, 64);
const KEY_MEDIA_EMAIL_READER: MediaKeyReport = MediaKeyReport(0, 128);

const BUTTON_1: u8 = 5; // Red (Meta)
const BUTTON_2: u8 = 4; // Black
const BUTTON_3: u8 = 1; // Blue
const BUTTON_4: u8 = 6; // Black
const BUTTON_5: u8 = 2; // Red (Meta)
const BUTTON_6: u8 = 7; // Black
const BUTTON_7: u8 = 3; // Blue
const BUTTON_8: u8 = 8; // Black

// Meta keys, much like the shift key on a regular keyboard
const META_1: u8 = BUTTON_1;
const META_2: u8 = BUTTON_5;

lazy_static! {
  // Button 2-4 & 6-8
   static ref REGULAR_LOOKUP: HashMap<u8, BLEEvent> = {
    let mut table = HashMap::new();
    table.insert(BUTTON_2, BLEEvent::MediaKey(KEY_MEDIA_PREV_TRACK));
    table.insert(BUTTON_3, BLEEvent::Letter(1));
    table
  };

  // Button 1
   static ref META_LOOKUP_1: HashMap<u8, BLEEvent> = {
    let mut table = HashMap::new();
    table.insert(BUTTON_2, BLEEvent::MediaKey(KEY_MEDIA_PREV_TRACK));
    table.insert(BUTTON_3, BLEEvent::MediaKey(KEY_MEDIA_NEXT_TRACK));
    table
  };

  // Button 6
  static ref META_LOOKUP_2: HashMap<u8, BLEEvent> = {
    let mut table = HashMap::new();
    table.insert(BUTTON_2, BLEEvent::MediaKey(KEY_MEDIA_PREV_TRACK));
    table.insert(BUTTON_2, BLEEvent::MediaKey(KEY_MEDIA_NEXT_TRACK));
    table
  };

  static ref ACTIVE_STATE: Mutex<PushState> = Mutex::new(PushState::Up(0));
}

impl PushState {
  // Allow us to keep track of the state of the button
  // @event The the click event (4 bytes)
  // @return 1. The new state of the button
  //         2. The event to send to the host
  //            1. MediaKeyReport (i.e Play/Pause)
  //            2. Letter (i.e. 'a')
  //            3. None (i.e. no event)
  pub fn transition(&self, event: &ClickEvent) -> (Self, Option<BLEEvent>) {
    use PushState::*;

    let next_state = match (event, *self) {
      // The button was released after being pressed
      // [Ok] Pressed -> Released (updated)
      ([.., 0, _], Down(id)) => Up(id),
      // A button has already been pushed
      // [User error] Pressed -> Pressed (ignored)
      ([.., _, _], Down(id)) => Down(id),

      // The button was released after being released
      // [Bug] Released -> Released (ignored)
      ([.., 0, _], Up(id)) => Up(id),

      // The button was pressed after being released
      // [Ok] Released -> Pressed (updated)
      ([.., id, _], Up(_)) => Down(*id),
    };

    let next_event = match (self, next_state) {
      // Meta key was pressed together with another key
      (Up(META_1), Down(id)) => META_LOOKUP_1.get(&id),

      // Meta key was pressed together with another key
      (Up(META_2), Down(id)) => META_LOOKUP_2.get(&id),

      // A regular key was pressed
      (_, Down(id)) => REGULAR_LOOKUP.get(&id),

      // A regular key was released
      (_, Up(_)) => None,
    };

    (next_state, next_event.cloned())
  }
}

// void transition_from_cpp(uint8_t *event);

#[no_mangle]
pub extern "C" fn transition_from_cpp(event: *const u8) {
  let event_slice: &[u8] = unsafe { std::slice::from_raw_parts(event, 4) };
  let mut click_event = [0u8; 4];
  click_event.copy_from_slice(event_slice);

  transition(&click_event);
}

fn transition(curr_event: &ClickEvent) {
  let mut active_state = ACTIVE_STATE.lock();
  let (next_state, next_event) = active_state.transition(curr_event);
  *active_state = next_state;

  let Some(event) = next_event else {
    return info!("No event to send to host");
  };

  match event {
    BLEEvent::MediaKey(report) => {
      info!("Sending media key report: {:?}", report);
    },
    BLEEvent::Letter(letter) => {
      info!("Sending letter: {:?}", letter);
    },
  }
}

#[cfg(test)]
mod tests {
  use std::assert_matches::assert_matches;

  use super::*;

  #[test]
  // [Pressed] Up -> Down
  fn test_up_to_down() {
    let state = PushState::Up(0);
    let event: ClickEvent = [0, 0, BUTTON_2, 0];
    let (next_state, next_event) = state.transition(&event);

    assert_matches!(next_state, PushState::Down(BUTTON_2));
    assert_matches!(next_event, Some(_));
  }

  #[test]
  // [Released]Â Down -> Up
  fn test_down_to_up() {
    let state = PushState::Down(BUTTON_2);
    let event: ClickEvent = [0, 0, 0, 0];
    let (next_state, next_event) = state.transition(&event);

    assert_matches!(next_state, PushState::Up(BUTTON_2));
    assert_matches!(next_event, None);
  }

  // [Invalid] Down -> Down
  fn test_down_to_down() {
    let state = PushState::Down(BUTTON_2);
    let event: ClickEvent = [0, 0, BUTTON_3, 0];
    let (next_state, next_event) = state.transition(&event);

    assert_matches!(next_state, PushState::Down(BUTTON_2));
    assert_matches!(next_event, None);
  }

  #[test]
  // [Invalid] Up -> Up
  fn test_up_to_up() {
    let state = PushState::Up(BUTTON_2);
    let event: ClickEvent = [0, 0, 0, 0];
    let (next_state, next_event) = state.transition(&event);

    assert_matches!(next_state, PushState::Up(BUTTON_2));
    assert_matches!(next_event, None);
  }

  #[test]
  // [Pressed] Up(Meta) -> Down
  fn test_meta_up_to_regular_down() {
    let prev_state = PushState::Up(META_1);
    let curr_event: ClickEvent = [0, 0, BUTTON_2, 0];
    let (next_state, next_event) = prev_state.transition(&curr_event);

    assert_matches!(next_state, PushState::Down(BUTTON_2));
    assert_matches!(next_event, Some(_));
  }

  #[test]
  // [Invalid] Up(Meta) -> Up
  fn test_meta_up_to_regular_up() {
    let prev_state = PushState::Up(META_1);
    let curr_event: ClickEvent = [0, 0, 0, 0];
    let (next_state, next_event) = prev_state.transition(&curr_event);

    assert_matches!(next_state, PushState::Up(META_1));
    assert_matches!(next_event, None);
  }
}
