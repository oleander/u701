#![no_std]

use lazy_static::lazy_static;


struct MediaKeyReport(u8, u8);
pub type ID = u8;

// The BLE event generated by the button
enum BLEEvent {
  MediaKey(MediaKeyReport),
  Letter(u8)
}

// The click event generated by the button
// Press event: [0, 0, ID, 0]
// Release event: [0, 0, 0, 0]
type ClickEvent = [u8; 4];

// If the button was released or pressed
#[derive(Copy, Clone, Debug, PartialEq)]
pub enum PushState {
  Down(ID),
  Up(ID),
}

const KEY_MEDIA_NEXT_TRACK: MediaKeyReport = MediaKeyReport(1, 0);
const KEY_MEDIA_PREVIOUS_TRACK: MediaKeyReport = MediaKeyReport(2, 0);
const KEY_MEDIA_STOP: MediaKeyReport = MediaKeyReport(4, 0);
const KEY_MEDIA_PLAY_PAUSE: MediaKeyReport = MediaKeyReport(8, 0);
const KEY_MEDIA_EJECT: MediaKeyReport = MediaKeyReport(16, 0);
const KEY_MEDIA_VOLUME_UP: MediaKeyReport = MediaKeyReport(32, 0);
const KEY_MEDIA_VOLUME_DOWN: MediaKeyReport = MediaKeyReport(64, 0);
const KEY_MEDIA_WWW_HOME: MediaKeyReport = MediaKeyReport(128, 0);
const KEY_MEDIA_LOCAL_MACHINE_BROWSER: MediaKeyReport = MediaKeyReport(0, 1);
const KEY_MEDIA_CALCULATOR: MediaKeyReport = MediaKeyReport(0, 2);
const KEY_MEDIA_WWW_BOOKMARKS: MediaKeyReport = MediaKeyReport(0, 4);
const KEY_MEDIA_WWW_SEARCH: MediaKeyReport = MediaKeyReport(0, 8);
const KEY_MEDIA_WWW_STOP: MediaKeyReport = MediaKeyReport(0, 16);
const KEY_MEDIA_WWW_BACK: MediaKeyReport = MediaKeyReport(0, 32);
const KEY_MEDIA_CONSUMER_CONTROL_CONFIGURATION: MediaKeyReport = MediaKeyReport(0, 64);
const KEY_MEDIA_EMAIL_READER: MediaKeyReport = MediaKeyReport(0, 128);

// Meta keys, much like the shift key on a regular keyboard
const META_1: u8 = 8;
const META_2: u8 = 9;

lazy_static! {
  // Button 2-4 & 6-8
   static ref REGULAR_LOOKUP: HashMap<u8, MediaKeyReport> = {
    let mut table = HashMap::new();
    table.insert(4, KEY_MEDIA_NEXT_TRACK);
    table.insert(50, KEY_MEDIA_NEXT_TRACK);
    table.insert(71, KEY_MEDIA_NEXT_TRACK);
    table
  }

  // Button 1
   static ref META_LOOKUP_1: HashMap<u8, MediaKeyReport> = {
    let mut table = HashMap::new();
    table.insert(4, KEY_MEDIA_NEXT_TRACK);
    table.insert(50, KEY_MEDIA_NEXT_TRACK);
    table.insert(71, KEY_MEDIA_NEXT_TRACK);
    table
  }

  // Button 6
   static ref META_LOOKUP_2: HashMap<u8, MediaKeyReport> = {
    let mut table = HashMap::new();
    table.insert(4, KEY_MEDIA_NEXT_TRACK);
    table.insert(50, KEY_MEDIA_NEXT_TRACK);
    table.insert(71, KEY_MEDIA_NEXT_TRACK);
    table
  }
}


impl PushState {
  // Allow us to keep track of the state of the button
  // @event The the click event (4 bytes)
  // @return 1. The new state of the button
  //         2. The event to send to the host
  //            1. MediaKeyReport (i.e Play/Pause)
  //            2. Letter (i.e. 'a')
  //            3. None (i.e. no event)
  pub fn transition(&self, event: &ClickEvent) -> (Self, Option<BLEEvent>) {
    use PushState::*;
    use BLEEvent::*;

    let next_state = match (event, *self) {
      // The button was released after being pressed
      // [Ok] Pressed -> Released (updated)
      ([.., 0, _], Down(id)) => Up(id),
      // A button has already been pushed
      // [User error] Pressed -> Pressed (ignored)
      ([.., _, _], Down(id)) => Down(id),

      // The button was released after being released
      // [Bug] Released -> Released (ignored)
      ([.., 0, _], Up(id)) => Up(id),

      // The button was pressed after being released
      // [Ok] Released -> Pressed (updated)
      ([.., id, _], Up(_)) => Down(*id),
    }

    let next_event = match (self, next_state) {
      // Meta key was pressed together with another key
      (Up(META_1), Down(id)) => {
        META_LOOKUP_1.get(&id).map(|key| MediaKey(*key))
      }

      // Meta key was pressed together with another key
      (Up(META_2), Down(id)) => {
        META_LOOKUP_2.get(&id).map(|key| MediaKey(*key))
      }

      // A regular key was pressed
      (_, Down(id)) => {
        REGULAR_LOOKUP.get(&id).map(|key| MediaKey(*key))
      },

      // A regular key was released
      (_, Up(_)) => None
    }

    (next_state, next_event)
  }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_push_state_transitions() {
        let state = PushState::Up(0);
        let event: ClickEvent = [0, 0, 4, 0]; // A press event for key with ID 4

        // Test transition from Up to Down
        let (next_state, next_event) = state.transition(&event);
        assert_eq!(next_state, PushState::Down(4));
        assert_eq!(next_event, Some(BLEEvent::MediaKey(KEY_MEDIA_NEXT_TRACK)));

        let state = next_state;
        let event: ClickEvent = [0, 0, 0, 0]; // A release event

        // Test transition from Down to Up
        let (next_state, next_event) = state.transition(&event);
        assert_eq!(next_state, PushState::Up(4));
        assert_eq!(next_event, None);
    }

    #[test]
    fn test_meta_key_transitions() {
        let state = PushState::Up(META_1);
        let event: ClickEvent = [0, 0, 4, 0]; // A press event for key with ID 4

        // Test transition with META_1 key pressed
        let (next_state, next_event) = state.transition(&event);
        assert_eq!(next_state, PushState::Down(4));
        assert_eq!(next_event, Some(BLEEvent::MediaKey(KEY_MEDIA_NEXT_TRACK)));

        let state = PushState::Up(META_2);
        // Test transition with META_2 key pressed
        let (next_state, next_event) = state.transition(&event);
        assert_eq!(next_state, PushState::Down(4));
        assert_eq!(next_event, Some(BLEEvent::MediaKey(KEY_MEDIA_NEXT_TRACK)));
    }
}

