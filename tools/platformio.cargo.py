# Cargo <-> PlatformIO integration script (autogenerated by cargo-pio)
# Calling 'pio run' will also build the Rust library crate by invoking Cargo
#
# How to use: Insert/update the following line in one of platformio.ini's environments:
# extra_scripts = platformio.cargo.py

import os

Import("env")

class Cargo:
    def run(self, env):
        self.__init_props(env)

        if self.__cargo_run_before_project:
            # Attach as a pre-action to all source files so that in case CBindgen is used
            # the C headers are generated before the files are compiled
            env.AddPreAction(Glob(os.path.join(env.subst("$BUILD_DIR"), "src/*.o")), self.__run_cargo)

            # Hack. Need to always run when a C file from the src directory is built, or else the include directories
            # passed to Cargo will not contain the includes coming from libraries imported with PlatformIO's Library Manager
            env.AlwaysBuild(os.path.join(env.subst("$BUILD_DIR"), "src/dummy.o"))

        env.AddPreAction("$BUILD_DIR/$PROGNAME$PROGSUFFIX", [self.__run_cargo, self.__link_cargo])

    def __init_props(self, env):
        self.__cargo_ran = False

        self.__rust_lib = env.GetProjectOption("rust_lib")
        self.__rust_target = env.GetProjectOption("rust_target")

        self.__rust_bindgen_enabled = env.GetProjectOption("rust_bindgen_enabled", default = "false").lower() == "true"
        self.__rust_bindgen_extra_clang_args = env.GetProjectOption("rust_bindgen_extra_clang_args", default = "")

        self.__cargo_run_before_project = env.GetProjectOption("cargo_run_before_project", default = "false").lower() == "true"
        self.__cargo_options = env.GetProjectOption("cargo_options", default = "")
        self.__cargo_profile = env.GetProjectOption(
            "cargo_profile",
            default = "release" if env.GetProjectOption("build_type") == "release" else "debug")
        self.__cargo_target_dir = env.GetProjectOption(
            "cargo_target_dir",
            default = os.path.join(env.subst("$PROJECT_BUILD_DIR"), "cargo")
                if env.GetProjectOption("cargo_pio_common_build_dir", default = "").lower() == "true"
                else os.path.join(env.subst("$PROJECT_DIR"), "target"))

    def __run_cargo(self, source, target, env):
        if self.__cargo_ran:
            return 0

        print(">>> CARGO")

        board_mcu = env.get("BOARD_MCU")
        if not board_mcu and "BOARD" in env:
            board_mcu = env.BoardConfig().get("build.mcu")

        env["ENV"]["CARGO_BUILD_TARGET_DIR"] = self.__cargo_target_dir
        env["ENV"]["CARGO_PIO_BUILD_PROJECT_DIR"] = env.subst("$PROJECT_DIR")
        env["ENV"]["CARGO_PIO_BUILD_RELEASE_BUILD"] = str(env.GetProjectOption("build_type", default = "release") == "release")

        env["ENV"]["CARGO_PIO_BUILD_PATH"] = env["ENV"]["PATH"]
        env["ENV"]["CARGO_PIO_BUILD_ACTIVE"] = "1"
        env["ENV"]["CARGO_PIO_BUILD_INC_FLAGS"] = env.subst("$_CPPINCFLAGS")
        env["ENV"]["CARGO_PIO_BUILD_LIB_FLAGS"] = env.subst("$_LIBFLAGS")
        env["ENV"]["CARGO_PIO_BUILD_LIB_DIR_FLAGS"] = env.subst("$_LIBDIRFLAGS")
        env["ENV"]["CARGO_PIO_BUILD_LIBS"] = env.subst("$LIBS")
        env["ENV"]["CARGO_PIO_BUILD_LINK_FLAGS"] = env.subst("$LINKFLAGS")
        env["ENV"]["CARGO_PIO_BUILD_LINK"] = env.subst("$LINK")
        env["ENV"]["CARGO_PIO_BUILD_LINKCOM"] = env.subst("$LINKCOM")
        env["ENV"]["CARGO_PIO_BUILD_MCU"] = board_mcu

        if self.__rust_bindgen_enabled:
            env["ENV"]["CARGO_PIO_BUILD_BINDGEN_RUN"] = "True"
            # platform = env.PioPlatform() 
            # platform.dump_used_packages()
            # packages = platform.get_installed_packages()
            
        #     print("CARGO_PIO_BUILD_INC_FLAGS", env["ENV"]["CARGO_PIO_BUILD_INC_FLAGS"])
            
        #     include_paths = []
        #     for package in packages:
        #         print("package: ", package.get_safe_dirname())
        #         name = package.get_safe_dirname()
        #         package_dir = platform.get_package_dir(name)
        #         if package_dir:
        #             for root, dirs, files in os.walk(package_dir):
        #                 for file in files:
        #                     if file.endswith('.h'):
        #                         include_paths.append(root)
        #                         break  # no need to continue in this dir

        # # Deduplicate and format the include paths
        # include_paths = set(include_paths)  # removes duplicates
        # formatted_includes = ' '.join(f'-I{path}' for path in include_paths)
        env["ENV"]["CARGO_PIO_BUILD_BINDGEN_EXTRA_CLANG_ARGS"] = env["ENV"]["CARGO_PIO_BUILD_INC_FLAGS"]

            
            # for package in packages:
            #     print("package: ", package)
            # # env.PioPlatform().get_package_dir("tool-cbindgen")
            # # base_path = env.PioPlatform().get_package_dir("framework-arduinoespressif32")
            # pkg_path = os.path.join(base_path, "cores", "esp32")
            # print("base_path: ", base_path)
            # print("pkg_path: ", pkg_path)
            # env["ENV"]["CARGO_PIO_BUILD_BINDGEN_EXTRA_CLANG_ARGS"] = f"-I{pkg_path} -I.pio/libdeps/release/ArduinoLog/ArduinoLog.h -I.pio/libdeps/release/OneButton/src/OneButton.h"

        env["ENV"]["CARGO_PIO_BUILD_PIO_PLATFORM_DIR"] = env.PioPlatform().get_dir()[0]
        env["ENV"]["CARGO_PIO_BUILD_PIO_FRAMEWORK_DIR"] = env.PioPlatform().get_package_dir(env.PioPlatform().frameworks[env.GetProjectOption("framework")[0]]["package"])

        self.__cargo_ran = True
        result = env.Execute(f"cargo build {'--release' if self.__cargo_profile == 'release' else ''} --lib --target {self.__rust_target} {self.__cargo_options}")

        print("<<< CARGO")

        return result

    def __link_cargo(self, source, target, env):
        env.Prepend(LINKFLAGS = ["-Wl,--allow-multiple-definition"]) # A hack to workaround this issue with Rust's compiler intrinsics: https://github.com/rust-lang/compiler-builtins/issues/353
        env.Prepend(LIBPATH = [env.subst(os.path.join(self.__cargo_target_dir, self.__rust_target, self.__cargo_profile))])
        env.Prepend(LIBS = [self.__rust_lib])

Cargo().run(env)
